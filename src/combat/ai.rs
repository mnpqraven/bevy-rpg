use bevy::prelude::*;
use iyes_loopless::prelude::*;
use rand::{thread_rng, Rng};

use crate::{combat::setup::setup_target_bucket, ecs::component::*};

use super::{process::TurnOrderList, ChooseAISkillEvent};
pub struct AiPlugin;

impl Plugin for AiPlugin {
    fn build(&self, app: &mut App) {
        app.add_system(choose_skill.run_in_state(GameState::InCombat));
    }
}

fn choose_skill(
    skill_q: Query<(Entity, &SkillGroupList, &Target), With<Skill>>,
    unit_q: Query<
        (Entity, Option<&Player>, Option<&Ally>, Option<&Enemy>),
        Or<(With<Player>, With<Ally>, With<Enemy>)>,
    >,
    turn_order: Res<TurnOrderList<Entity, Speed>>,
    mut ev_castskill: EventWriter<CastSkillEvent>,
    mut ev_choose_ai_skill: EventReader<ChooseAISkillEvent>,
) {
    for _ in ev_choose_ai_skill.iter() {
        if !&turn_order.is_empty() {
            let (unit_ent, _, ally_tag, enemy_tag) = unit_q
                .get(
                    *turn_order
                        .get_current()
                        .expect("turn order vec should be generated by now"),
                )
                .unwrap();
            let filter: SkillGroup = match true {
                true if ally_tag.is_some() => SkillGroup::Ally,
                true if enemy_tag.is_some() => SkillGroup::Enemy,
                _ => SkillGroup::Universal,
            };
            // grab a random skill
            // gather all skills from either enemy grp or ally
            let pool: Vec<(Entity, &SkillGroupList, &Target)> = skill_q
                .iter()
                .filter(|item| item.1 .0.contains(&filter))
                .collect();
            let rng_index = thread_rng().gen_range(0..pool.len());
            let target_type = pool[rng_index].2.clone();

            let filtered_units = setup_target_bucket(
                unit_q.to_readonly(),
                target_type,
                *turn_order
                    .get_current()
                    .expect("turnorder should be generated by now"),
                unit_q
                    .get(*turn_order.get_current().unwrap())
                    .unwrap()
                    .3
                    .is_some(),
            );
            debug!("{:?}", filtered_units);

            ev_castskill.send(CastSkillEvent {
                skill_ent: SkillMeta(pool[rng_index].0),
                target: filtered_units[0],
                caster: unit_ent,
            });
        }
    }
}

